#version 330 core

in vec2 texCoords;

uniform vec2 resolution; //window resolution

const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0f;
const float MAX_DIST = 100.0f;
const float EPSILON = 0.0001f;

float getDistance(vec3 point){
//and this.... dist at z must be > radius
    vec4 sphere = vec4(0.0f, 0.0f, 4.0f, 3.9998f);
    float sphereDist = length(point - sphere.xyz) - sphere.w;

    return sphereDist;
}

float rayMarch(vec3 eye, vec3 marchingDirection, float start, float end){
    float depth = start;

    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = getDistance(eye + depth * marchingDirection);
        if (dist < EPSILON) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }

    return end;
}

vec3 getNormal(vec3 p){
    return normalize(vec3(
        getDistance(vec3(p.x + EPSILON, p.y, p.z)) - getDistance(vec3(p.x - EPSILON, p.y, p.z)),
        getDistance(vec3(p.x, p.y + EPSILON, p.z)) - getDistance(vec3(p.x, p.y - EPSILON, p.z)),
        getDistance(vec3(p.x, p.y, p.z  + EPSILON)) - getDistance(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

float getLight(vec3 p){
    vec3 lightPos = vec3(0, 5, 0);
    vec3 light = normalize(lightPos - p);
    vec3 normal = getNormal(p);

    float dif = dot(normal, light);
    return dif;
}

void main()
{
    vec2 pixelCoord = gl_FragCoord.xy;
    vec2 uv = vec2(pixelCoord.x - resolution.x/2.0f, pixelCoord.y - resolution.y/2.0f);

    vec3 rayOrigin = vec3(0.0f, 0.0f, 0.0f);
    vec3 rayDir = normalize(vec3(uv, 1.0f));

    float distanceToSurface = rayMarch(rayOrigin, rayDir, MIN_DIST, MAX_DIST);

    vec3 p = rayOrigin + rayDir * distanceToSurface;

    float dif = getLight(p);

    if (distanceToSurface > MAX_DIST - EPSILON) {
        // Didn't hit anything
        gl_FragColor = vec4(0.0f, 1.0f, 0.0f, 0.0f);
		return;
    }

    vec3 col = vec3(dif);
    
    gl_FragColor = vec4(col, 1.0f);
}
